#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a CSharp implementation

@author NiiAAip <jy.wang@yuneec.com>
'''
from __future__ import print_function

from builtins import range
import os
import platform
from . import mavtemplate

t = mavtemplate.MAVTemplate()

# todo - refactor this in to the other array
map = {
        'float'    : 'float',
        'double'   : 'double',
        'char'     : 'char',
        'int8_t'   : 'sbyte',
        'uint8_t'  : 'byte',
        'uint8_t_mavlink_version'  : 'B',
        'int16_t'  : 'Int16',
        'uint16_t' : 'UInt16',
        'int32_t'  : 'Int32',
        'uint32_t' : 'UInt32',
        'int64_t'  : 'Int64',
        'uint64_t' : 'UInt64',
        }

# Map of field type to bitconverter bytedecoding function, and number of bytes used for the encoding
mapType = {
        'float'    : 'ReadSingle',
        'double'   : 'ReadDouble',
        'int8_t'   : 'ReadSByte',
        'uint8_t'  : 'ReadByte',
        'char'     : 'ReadChar',
        'int16_t'  : 'ReadInt16',
        'uint16_t' : 'ReadUInt16',
        'int32_t'  : 'ReadInt32',
        'uint32_t' : 'ReadUInt32',
        'int64_t'  : 'ReadInt64',
        'uint64_t' : 'ReadUInt64',
        }    

# Map of field names to names that are C# compatible and not illegal class field names
mapFieldName = {
        'fixed'    : '@fixed'
        } 

def copy_fixed_headers(directory, xml):
    '''copy the fixed protocol headers to the target directory'''
    import shutil, filecmp
    hlist = {
        "1.0": [ 'BlockingCircularStream.cs', 'MavLinkAsyncWalker.cs', 'MavLinkGenericPacketWalker.cs', 'MavLinkGenericTransport.cs', 
                 'MavLinkLogFileTransport.cs', 'MavLinkPacket.cs', 'MavLinkSerialPortTransport.cs', 'MavLinkState.cs', 
                 'MavLinkUdpTransport.cs', 'UasMessage.cs' ],
        "2.0": [ 'BlockingCircularStream.cs', 'MavLinkAsyncWalker.cs', 'MavLinkGenericPacketWalker.cs', 'MavLinkGenericTransport.cs', 
                 'MavLinkLogFileTransport.cs', 'MavLinkPacket.cs', 'MavLinkSerialPortTransport.cs', 'MavLinkState.cs', 
                 'MavLinkUdpTransport.cs', 'UasMessage.cs' ]
        }
    basepath = os.path.dirname(os.path.realpath(__file__))
    srcpath = os.path.join(basepath, 'CS/include_v%s' % xml.wire_protocol_version)
    print("Copying fixed headers for protocol %s to %s" % (xml.wire_protocol_version, directory))
    for h in hlist[xml.wire_protocol_version]:
        src = os.path.realpath(os.path.join(srcpath, h))
        dest = os.path.realpath(os.path.join(directory, h))
        if src == dest or (os.path.exists(dest) and filecmp.cmp(src, dest)):
            continue
        shutil.copy(src, dest)

def generate_preamble(outf, msgs, args):
    print("Generating preamble")
    t.write(outf, """
/*
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

using System;
using System.IO;
using System.Collections.Generic;

namespace MavLinkNet
{
""", {'FILELIST' : ",".join(args)})

def generate_xmlDocSummary(outf, summaryText, tabDepth):
    indent = '\t' * tabDepth
    escapedText = summaryText.replace("\n","\n%s///" % indent)
    outf.write("\n%s/// <summary>\n" % indent)
    outf.write("%s/// %s\n" % (indent, escapedText))
    outf.write("%s/// </summary>\n" % indent)
    
    
def generate_enums(outf, enums):
    print("Generating enums")
    for e in enums:
        if len(e.description) > 0:
            generate_xmlDocSummary(outf, e.description, 1)
        outf.write("\tpublic enum %s\n\t{\n" % e.name)

        for entry in e.entry:
            if len(entry.description) > 0:
                generate_xmlDocSummary(outf, entry.description, 2)
            outf.write("\t\t%s = %u,\n" % (entry.name, entry.value))

        outf.write("\t\t%s_ENUM_END\n\t}\n\n" % e.name)

def generate_classes(outf, msgs):
    print("Generating class definitions")
    for m in msgs:
        if (len(m.description) >0):
            generate_xmlDocSummary(outf, m.description, 1)
        outf.write("\tpublic class Uas%s : UasMessage\n\t{\n" % m.name)
    
        for f in m.ordered_fields:
            if (f.description.upper() != f.name.upper()):
                generate_xmlDocSummary(outf, f.description, 2)
            if (f.array_length):
                outf.write("\t\tpublic %s[] %s // Array size %s\n\t\t{\n\t\t\tget { return _%s; }\n\t\t\tset { _%s = value; }\n" % (map[f.type], mapFieldName.get(f.name, f.name).capitalize(), f.array_length, f.name,f.name))
            else:
                if (f.enum):
                    outf.write("\t\tpublic %s %s // Array size %s\n\t\t{\n\t\t\tget { return _%s; }\n\t\t\tset { _%s = value; }\n" % (f.enum,mapFieldName.get(f.name, f.name).capitalize(), f.array_length, f.name,f.name))
                else:                       
                    outf.write("\t\tpublic %s %s // Array size %s\n\t\t{\n\t\t\tget { return _%s; }\n\t\t\tset { _%s = value; }\n" % (map[f.type], mapFieldName.get(f.name, f.name).capitalize(), f.array_length, f.name,f.name))
            outf.write("\t\t}\n")

        outf.write("""
        public Uas%s()
        {
            mMessageId = %s;
            CrcExtra = %s;
        }        
""" % (m.name,m.id,m.crc_extra))

        outf.write("""
        internal override void SerializeBody(BinaryWriter s)
        {   
""")
        for f in m.ordered_fields:
            if (f.array_length):
                if f.type == 'char' or f.type == 'uint8_t':
                    outf.write("\t\t\ts.Write(_%s);\n" % f.name)
                else:
                    #for i in range(0,f.array_length):
                    outf.write("\t\t\tfor(int i = 0; i < %s; i++) s.Write(_%s[i]);\n" % (f.array_length,f.name))
            else:
                if f.enum:
                    outf.write("\t\t\ts.Write((%s)_%s);\n" % (map[f.type],f.name))
                else:
                    outf.write("\t\t\ts.Write(_%s);\n" % f.name)
        outf.write("\t\t}\n")

        outf.write("""
        internal override void DeserializeBody(BinaryReader s)
        {   
""")
        for f in m.ordered_fields:
            if (f.array_length):
                if f.type == 'char' or f.type == 'uint8_t':
                    outf.write("\t\t\t_%s = s.%ss(%s);\n" % (f.name,mapType[f.type],f.array_length))
                else:
                    # for i in range(0,f.array_length):
                    outf.write("\t\t\tfor(int i = 0; i < %s; i++) _%s[i] = s.%s();\n" % (f.array_length,f.name,mapType[f.type]))
            else:
                if f.enum:
                    outf.write("\t\t\t_%s = (%s)s.%s();\n" % (f.name,f.enum,mapType[f.type]))
                else:
                    outf.write("\t\t\t_%s = s.%s();\n" % (f.name,mapType[f.type]))
        outf.write("\t\t}\n")

        outf.write("""
        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata()
            {
                Description = "Uas%s;%s"
            };
""" % (m.name,m.description))
        for f in m.ordered_fields:
            if (f.array_length):
                if f.type == 'char':
                    outf.write("""
            mMetadata.Fields.Add(new UasFieldMetadata()
            {
                Name = "%s",
                Description = "%s",
                Value = new string(_%s),
                NumElements = 1,
            });
""" % (f.name.capitalize(),f.description,f.name))
                else:
                    #for i in range(0,f.array_length):
                    outf.write("""
            for(int i = 0; i < %s; i++)
                mMetadata.Fields.Add(new UasFieldMetadata()
                {
                    Name = "%s" + i.ToString(),
                    Description = "%s",
                    Value = _%s[i].ToString(),
                    NumElements = 1,
                });
""" % (f.array_length,f.name.capitalize(),f.description,f.name))
            else:
                outf.write("""
            mMetadata.Fields.Add(new UasFieldMetadata()
            {
                Name = "%s",
                Description = "%s",
                Value = _%s.ToString(),
                NumElements = 1,
            });
""" % (f.name.capitalize(),f.description,f.name))
        outf.write("\t\t}\n\n")

        for f in m.ordered_fields:
            if (f.array_length):
                outf.write("\t\tprivate %s[] _%s = new %s[%s];\n" % (map[f.type],f.name,map[f.type],f.array_length))
            else:
                if f.enum:
                    outf.write("\t\tprivate %s _%s;\n" % (f.enum,f.name))
                else:
                    outf.write("\t\tprivate %s _%s;\n" % (map[f.type],f.name))

        outf.write("\t}\n")

def generate_summary(outf, msgs, enums):
    '''generate UasSummary class'''
    print("Generating class UasSummary")
    outf.write("""
    public class UasSummary
    {
        public static UasMessage CreateFromId(uint id)
        {
            switch (id)
            {
""")
    for m in msgs:
        outf.write("\t\t\t\tcase %s: return new Uas%s();\n" % (m.id,m.name))
    outf.write("""\t\t\t\tdefault: return null;
            }
        }
""")

    outf.write("""
        public static byte GetCrcExtraForId(uint id)
        {
            switch (id)
            {
""")
    for m in msgs:
        outf.write("\t\t\t\tcase %s: return %s;\n" % (m.id,m.crc_extra))
    outf.write("""\t\t\t\tdefault: return 0;
            }
        }
    }
""")

    outf.write("""
        private static Dictionary<string, UasEnumMetadata> mEnums;

        public static UasEnumMetadata GetEnumMetadata(string enumName)
        {
            if (mEnums == null) InitEnumMetadata();

            return mEnums[enumName];
        }

        private static void InitEnumMetadata()
        {
            UasEnumMetadata en = null;
            UasEnumEntryMetadata ent = null;
            mEnums = new Dictionary<string, UasEnumMetadata>();
""")
    for e in enums:
        outf.write("""
            en = new UasEnumMetadata()
            {
                Name = "%s",
                Description = "%s",
            };
""" % (e.name,e.description))
        for et in e.entry:
            outf.write("""
            ent = new UasEnumEntryMetadata()
            {
                Value = %s,
                Name = "%s",
                Description = "%s",
            };
""" % (et.value,et.name,e.description))
            if len(et.param) > 0:
                outf.write("\t\t\tent.Params = new List<String>();\n")
                for par in et.param:
                    outf.write("""\t\t\tent.Params.Add("%s");\n""" % par.description)
            outf.write("\t\t\ten.Entries.Add(ent);\n")

        outf.write("\t\t\tmEnums.Add(en.Name, en);\n")

    outf.write("}\n\n")

def generate(basename, xml):
    '''generate complete MAVLink CSharp implemenation'''
    structsfilename = os.path.join(basename, "GenerateMessages.cs")

    msgs = []
    enums = []
    filelist = []
    name_enums = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))
    for n in enums:
        name_enums.append(n.name)
    for m in msgs:
        namestrs = m.name.lower().split('_')
        namefull = ''
        for s in namestrs:
            namefull += s.capitalize()
        m.name = namefull
        for f in m.ordered_fields:
            fstrs = f.name.lower().split('_')
            prname = ''.join(fstrs[0])
            for s in fstrs[1:]:
                prname += s.capitalize()
            f.name = prname
            if f.enum not in name_enums:
                f.enum = ''
            
    print("Generating messages file: %s" % structsfilename)
    dir = os.path.dirname(structsfilename)
    if not os.path.exists(dir):
        os.makedirs(dir)
    outf = open(structsfilename, "w")
    generate_preamble(outf, msgs, filelist)
    generate_enums(outf, enums)
    generate_classes(outf, msgs)
    generate_summary(outf, msgs, enums)
    outf.close()
    print("Generated %s OK" % structsfilename)
    copy_fixed_headers(basename, xml[0])